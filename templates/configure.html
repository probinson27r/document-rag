<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configure - ED19024 AI Assistant</title>
    <style>
        html, body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .topbar {
            width: 100vw; display: flex; justify-content: flex-end; align-items: center;
            background: rgba(255,255,255,0.1); padding: 16px 30px; position: relative;
            box-sizing: border-box;
        }
        .back-link {
            color: #3b82f6; background: white; border-radius: 6px; padding: 8px 18px;
            font-size: 14px; font-weight: 500; text-decoration: none; box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            transition: background 0.2s;
        }
        .back-link:hover {
            background: #e0e7ef;
        }
        .config-content {
            max-width: 440px; width: 100%; margin: 40px auto; background: rgba(255,255,255,0.95); border-radius: 12px; box-shadow: 0 4px 32px rgba(0,0,0,0.08); padding: 32px 32px 24px 32px;
            box-sizing: border-box;
        }
        .section-title {
            color: #1f2937; font-size: 16px; font-weight: 600; margin-bottom: 15px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .model-section { margin-bottom: 24px; }
        .model-label { color: #1f2937; font-size: 13px; font-weight: 500; margin-bottom: 6px; display: block; }
        .model-select {
            width: 100%; background: #f3f4f6; border: 1px solid #d1d5db;
            color: #1f2937; padding: 8px 12px; border-radius: 4px; font-size: 13px;
            outline: none; margin-bottom: 8px;
        }
        .instructions-section { margin-bottom: 20px; }
        .instructions-textarea {
            width: 100%; background: rgba(59,130,246,0.07); border: 1px solid #d1d5db;
            color: #1f2937; padding: 12px; border-radius: 6px; font-size: 13px; min-height: 120px;
            outline: none; resize: vertical; font-family: inherit;
        }
        .instructions-textarea::placeholder { color: #6b7280; }
        .instructions-buttons { display: flex; gap: 8px; margin-top: 10px; }
        .instructions-btn {
            background: #3b82f6; border: none; color: white; padding: 6px 16px; border-radius: 4px; font-size: 12px;
            cursor: pointer; transition: background 0.2s;
        }
        .instructions-btn:hover { background: #2563eb; }
        .instructions-btn.secondary {
            background: #e5e7eb; color: #1f2937;
        }
        .instructions-btn.secondary:hover { background: #d1d5db; }
        .upload-area {
            border: 2px dashed #3b82f6; border-radius: 8px; padding: 20px;
            text-align: center; color: #3b82f6; cursor: pointer;
            transition: all 0.3s ease; margin-bottom: 20px; background: #f3f4f6;
        }
        .upload-area:hover { border-color: #2563eb; background: #e0e7ef; }
        .file-input { display: none; }
        .document-list { max-height: 300px; overflow-y: auto; margin-bottom: 10px; }
        .document-item {
            background: #f3f4f6; border-radius: 6px; padding: 12px; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .document-info { flex: 1; min-width: 0; }
        .document-name {
            color: #1f2937; font-size: 13px; font-weight: 500;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .document-meta { color: #6b7280; font-size: 11px; margin-top: 2px; }
        .delete-btn {
            background: #fee2e2; border: none; color: #ef4444;
            width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            margin-left: 4px;
        }
        .view-chunks-btn {
            background: #e0e7eb; border: none; color: #3b82f6;
            padding: 4px 10px; border-radius: 4px; font-size: 12px; cursor: pointer;
            margin-right: 4px;
        }
        .view-chunks-btn:hover { background: #d1d5db; }
        /* Modal styles */
        .modal-bg {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.5); z-index: 10001; justify-content: center; align-items: center;
        }
        .modal-content {
            background: white; max-width: 700px; width: 90vw; max-height: 80vh; overflow: auto;
            border-radius: 10px; padding: 30px; position: relative; box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        .close-modal-btn {
            position: absolute; top: 10px; right: 10px; background: #eee; border: none; border-radius: 50%; width: 32px; height: 32px; font-size: 18px; cursor: pointer;
        }
        @media (max-width: 600px) {
            .config-content { padding: 16px 4vw 12px 4vw; }
        }
    </style>
</head>
<body>
    <div class="topbar">
        <a href="/chat" class="back-link">← Back to Chat</a>
    </div>
    <div class="config-content">
        <div class="section-title">Model Selection</div>
        <div class="model-section">
            <label class="model-label" for="modelSelect">Current Model</label>
            <select class="model-select" id="modelSelect">
                <option value="">Loading models...</option>
            </select>
        </div>
        
        <div class="section-title">Extraction Configuration</div>
        <div class="model-section" id="temperatureSection">
            <label class="model-label" for="temperatureInput">AI Temperature (0.0 = deterministic, 1.0 = creative)</label>
            <input id="temperatureInput" type="range" min="0" max="1" step="0.05" value="0.7" class="model-select" style="padding:0;height:32px;">
            <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">
                Current: <span id="temperatureValue">0.7</span>
            </div>
        </div>
        <div class="model-section" id="extractionMethodSection">
            <label class="model-label" for="extractionMethodSelect">Document Extraction Method</label>
            <select class="model-select" id="extractionMethodSelect">
                <option value="auto">Auto (Best Available)</option>
                <option value="gpt4_enhanced">GPT-4 Enhanced</option>
                <option value="traditional">Traditional Only</option>
            </select>
            <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">
                GPT-4 Enhanced: Uses AI to improve text extraction and extract structured data
            </div>
        </div>
        
        <div class="model-section" id="chunkingMethodSection">
            <label class="model-label" for="chunkingMethodSelect">Document Chunking Method</label>
            <select class="model-select" id="chunkingMethodSelect">
                <option value="semantic">Semantic Chunking (Default)</option>
                <option value="langextract">LangExtract (Google AI)</option>
                <option value="gpt4">GPT-4 Chunking</option>
                <option value="traditional">Traditional Chunking</option>
            </select>
            <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">
                Semantic: Preserves document sections and lists | LangExtract: Google's intelligent structure extraction | GPT-4: AI-powered chunking
            </div>
            <div id="langextractNotice" style="font-size: 11px; color: #059669; margin-top: 4px; display: none;">
                ℹ️ LangExtract automatically uses Google GenAI (not GPT-4) for optimal document structure extraction
            </div>
        </div>
        
        <div class="model-section" id="gpt4FeaturesSection">
            <label class="model-label">GPT-4 Extraction Features</label>
            <div style="background: #f9fafb; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                <label style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="enableTextEnhancement" checked style="margin-right: 8px;">
                    Text Enhancement (Clean & format extracted text)
                </label>
                <label style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="enableStructuredData" checked style="margin-right: 8px;">
                    Structured Data Extraction (Dates, names, amounts, etc.)
                </label>
                <label style="display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;">
                    <input type="checkbox" id="enableContractAnalysis" checked style="margin-right: 8px;">
                    Contract Analysis (Legal document insights)
                </label>
                <label style="display: flex; align-items: center; font-size: 12px;">
                    <input type="checkbox" id="enableDocumentSummary" style="margin-right: 8px;">
                    Document Summary (Generate summaries)
                </label>
            </div>
        </div>
        
        <div class="model-section" id="gpt4ModelSection">
            <label class="model-label" for="gpt4ModelSelect">GPT-4 Model</label>
            <select class="model-select" id="gpt4ModelSelect">
                <option value="gpt-4o">GPT-4o (Fast & Cost-effective)</option>
                <option value="gpt-4">GPT-4 (High Quality)</option>
                <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
            </select>
        </div>
        
        <div class="model-section" id="ocrConfigSection">
            <label class="model-label">OCR (Optical Character Recognition)</label>
            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                <input type="checkbox" id="enableOcr" style="margin-right: 8px;">
                <label for="enableOcr" style="font-size: 13px; color: #374151;">Enable OCR for scanned documents</label>
            </div>
            <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">
                <strong>Disabled by default for faster processing.</strong><br>
                Enable only for scanned documents or PDFs with poor text extraction.<br>
                OCR converts PDF pages to images for text extraction (slower but more accurate for scanned content).
            </div>
        </div>
        
        <div class="model-section" id="extractionStatusSection">
            <label class="model-label">Extraction System Status</label>
            <div id="extractionStatus" style="background: #f9fafb; border-radius: 6px; padding: 12px; font-size: 12px;">
                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                    <span id="statusIndicator" style="width: 8px; height: 8px; border-radius: 50%; background: #6b7280; margin-right: 8px;"></span>
                    <span id="statusText">Checking system status...</span>
                </div>
                <div id="statusDetails" style="color: #6b7280; font-size: 11px;">
                    Loading capabilities...
                </div>
                <button id="testExtractionBtn" class="instructions-btn" style="margin-top: 8px; font-size: 11px; padding: 4px 12px;">
                    Test Extraction
                </button>
            </div>
        </div>
        <div class="section-title">AI Instructions</div>
        <div class="instructions-section">
            <textarea class="instructions-textarea" id="instructionsTextarea" 
                      placeholder="Customize how the AI should behave and respond to your questions..."></textarea>
            <div class="instructions-buttons">
                <button class="instructions-btn" id="saveInstructionsBtn">Save</button>
                <button class="instructions-btn secondary" id="resetInstructionsBtn">Reset</button>
            </div>
        </div>
        <div class="section-title">Upload Legal Documents</div>
        <div class="upload-area" id="uploadArea">
            <div>📄 Drop legal documents here or click to browse</div>
            <div style="font-size: 12px; margin-top: 5px; opacity: 0.7;">
                PDF, DOCX, TXT, CSV, JSON
            </div>
            <div id="uploadProgress" style="display: none; margin-top: 10px;">
                <div style="background: #e5e7eb; border-radius: 4px; height: 6px; overflow: hidden;">
                    <div id="progressBar" style="background: #3b82f6; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="progressText" style="font-size: 11px; color: #6b7280; margin-top: 4px;">0%</div>
            </div>
        </div>
        <input type="file" class="file-input" id="fileInput" 
               accept=".pdf,.docx,.txt,.csv,.json" multiple>
        <div class="section-title">Your Documents (<span id="docCount">0</span>)</div>
        <div class="document-list" id="documentList">
            <div style="color: #6b7280; text-align: center; padding: 20px; font-size: 14px;">
                Loading documents...
            </div>
        </div>
    </div>
    <!-- Modal for viewing chunks -->
    <div class="modal-bg" id="chunkModalBg">
        <div class="modal-content">
            <button class="close-modal-btn" id="closeChunkModal">×</button>
            <div id="chunkModalTitle" style="font-size:18px;font-weight:600;margin-bottom:18px;"></div>
            <div id="chunkModalBody" style="font-size:13px;line-height:1.6;"></div>
        </div>
    </div>
    <script>
    // Model selection
    async function loadModels() {
        const modelSelect = document.getElementById('modelSelect');
        try {
            const response = await fetch('/api/models');
            const data = await response.json();
            modelSelect.innerHTML = '';
            if (data.available_models && data.available_models.length > 0) {
                data.available_models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    if (model === data.current_model) option.selected = true;
                    modelSelect.appendChild(option);
                });
            }
            modelSelect.addEventListener('change', async function() {
                const selectedModel = this.value;
                if (selectedModel && selectedModel !== data.current_model) {
                    await switchModel(selectedModel);
                }
            });
        } catch (error) {
            modelSelect.innerHTML = '<option>Error loading models</option>';
        }
    }
    
    // Extraction configuration
    async function loadExtractionConfig() {
        try {
            // Load chat (temperature) config
            const chatCfgResp = await fetch('/api/chat/config');
            const chatCfg = await chatCfgResp.json();
            if (!chatCfgResp.ok) throw new Error('chat config load failed');
            const tempInput = document.getElementById('temperatureInput');
            const tempValue = document.getElementById('temperatureValue');
            const t = typeof chatCfg.temperature === 'number' ? chatCfg.temperature : 0.7;
            tempInput.value = t;
            tempValue.textContent = Number(t).toFixed(2);

            const response = await fetch('/api/extraction/config');
            const data = await response.json();
            
            // Set extraction method
            const extractionMethodSelect = document.getElementById('extractionMethodSelect');
            extractionMethodSelect.value = data.extraction_method || 'auto';
            
            // Set GPT-4 model
            const gpt4ModelSelect = document.getElementById('gpt4ModelSelect');
            gpt4ModelSelect.value = data.gpt4_model || 'gpt-4o';
            
            // Set chunking method
            const chunkingMethodSelect = document.getElementById('chunkingMethodSelect');
            chunkingMethodSelect.value = data.chunking?.method || 'semantic';
            
            // Set feature checkboxes
            document.getElementById('enableTextEnhancement').checked = data.features?.text_enhancement !== false;
            document.getElementById('enableStructuredData').checked = data.features?.structured_data !== false;
            document.getElementById('enableContractAnalysis').checked = data.features?.contract_analysis !== false;
            document.getElementById('enableDocumentSummary').checked = data.features?.document_summary === true;
            
            // Set OCR configuration
            document.getElementById('enableOcr').checked = data.ocr?.enabled === true;
            
        } catch (error) {
            console.error('Failed to load extraction config:', error);
            showNotification('Failed to load extraction configuration', 'warning');
        }
    }
    
    async function saveExtractionConfig() {
        try {
            const chunkingMethod = document.getElementById('chunkingMethodSelect').value;
            let extractionMethod = document.getElementById('extractionMethodSelect').value;
            
            // Auto-adjust extraction method for LangExtract
            if (chunkingMethod === 'langextract') {
                extractionMethod = 'auto';  // Use 'auto' instead of 'traditional' for LangExtract
                document.getElementById('extractionMethodSelect').value = 'auto';
                console.log('LangExtract selected: automatically set extraction method to auto');
            }
            
            const config = {
                extraction_method: extractionMethod,
                gpt4_model: document.getElementById('gpt4ModelSelect').value,
                chunking: {
                    method: chunkingMethod
                },
                features: {
                    text_enhancement: document.getElementById('enableTextEnhancement').checked,
                    structured_data: document.getElementById('enableStructuredData').checked,
                    contract_analysis: document.getElementById('enableContractAnalysis').checked,
                    document_summary: document.getElementById('enableDocumentSummary').checked
                },
                ocr: {
                    enabled: document.getElementById('enableOcr').checked
                }
            };

            // Save chat (temperature) config in parallel
            const temp = parseFloat(document.getElementById('temperatureInput').value || '0.7');
            const saveChatCfg = fetch('/api/chat/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ temperature: Math.max(0, Math.min(1, isNaN(temp) ? 0.7 : temp)) })
            });
            
            const response = await fetch('/api/extraction/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(config)
            });
            await saveChatCfg;
            
            const result = await response.json();
            if (response.ok) {
                showNotification('Extraction configuration saved successfully', 'success');
            } else {
                showNotification(`Failed to save extraction config: ${result.error}`, 'error');
            }
        } catch (error) {
            showNotification('Failed to save extraction configuration', 'error');
        }
    }
    
    // Update extraction method visibility based on selection
    function updateExtractionUI() {
        const extractionMethod = document.getElementById('extractionMethodSelect').value;
        const chunkingMethod = document.getElementById('chunkingMethodSelect').value;
        const gpt4Features = document.getElementById('gpt4FeaturesSection');
        const gpt4Model = document.getElementById('gpt4ModelSection');
        const statusSection = document.getElementById('extractionStatusSection');
        const langextractNotice = document.getElementById('langextractNotice');
        
        if (gpt4Features && gpt4Model && statusSection) {
            if (extractionMethod === 'gpt4_enhanced') {
                gpt4Features.style.display = 'block';
                gpt4Model.style.display = 'block';
                statusSection.style.display = 'block';
            } else {
                gpt4Features.style.display = 'none';
                gpt4Model.style.display = 'none';
                statusSection.style.display = 'none';
            }
        }
        
        // Show/hide LangExtract notice
        if (langextractNotice) {
            langextractNotice.style.display = chunkingMethod === 'langextract' ? 'block' : 'none';
        }
    }
    
    // Load extraction system status
    async function loadExtractionStatus() {
        try {
            const response = await fetch('/api/extraction/status');
            const data = await response.json();
            
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const statusDetails = document.getElementById('statusDetails');
            
            if (data.gpt4_available) {
                statusIndicator.style.background = '#10b981'; // Green
                statusText.textContent = 'GPT-4 Extraction Available';
                statusDetails.innerHTML = `
                    <strong>Available Models:</strong> ${data.available_models.join(', ')}<br>
                    <strong>System Status:</strong> ${data.system_status}<br>
                    <strong>Current Method:</strong> ${data.current_config.extraction_method}
                `;
            } else {
                statusIndicator.style.background = '#f59e0b'; // Orange
                statusText.textContent = 'GPT-4 Extraction Limited';
                statusDetails.innerHTML = `
                    <strong>Status:</strong> Traditional extraction only<br>
                    <strong>Reason:</strong> No GPT-4 API keys configured<br>
                    <strong>Available:</strong> Basic text extraction
                `;
            }
        } catch (error) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const statusDetails = document.getElementById('statusDetails');
            
            statusIndicator.style.background = '#ef4444'; // Red
            statusText.textContent = 'Status Check Failed';
            statusDetails.textContent = 'Unable to check extraction system status';
        }
    }
    async function switchModel(newModel) {
        try {
            const response = await fetch('/api/models/switch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model: newModel })
            });
            const result = await response.json();
            if (response.ok) {
                showNotification(`Switched to ${newModel}`, 'success');
            } else {
                showNotification(`Failed to switch model: ${result.error}`, 'error');
            }
        } catch (error) {
            showNotification('Failed to switch model', 'error');
        }
    }
    // Instructions
    async function loadInstructions() {
        try {
            const response = await fetch('/api/instructions');
            const data = await response.json();
            document.getElementById('instructionsTextarea').value = data.instructions || '';
        } catch (error) {
            showNotification('Failed to load AI instructions', 'warning');
        }
    }
    async function saveInstructions() {
        try {
            const instructions = document.getElementById('instructionsTextarea').value.trim();
            if (!instructions) {
                showNotification('Instructions cannot be empty', 'error');
                return;
            }
            const response = await fetch('/api/instructions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ instructions })
            });
            const result = await response.json();
            if (response.ok) {
                showNotification('AI instructions updated successfully', 'success');
            } else {
                showNotification(`Failed to save instructions: ${result.error}`, 'error');
            }
        } catch (error) {
            showNotification('Failed to save instructions', 'error');
        }
    }
    async function resetInstructions() {
        try {
            const response = await fetch('/api/instructions/reset', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
            });
            const result = await response.json();
            if (response.ok) {
                document.getElementById('instructionsTextarea').value = result.instructions || '';
                showNotification('AI instructions reset to default', 'success');
            } else {
                showNotification(`Failed to reset instructions: ${result.error}`, 'error');
            }
        } catch (error) {
            showNotification('Failed to reset instructions', 'error');
        }
    }
    // Document upload and list
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    function renderDocuments(docs) {
        const documentList = document.getElementById('documentList');
        const docCount = document.getElementById('docCount');
        if (!docs || docs.length === 0) {
            documentList.innerHTML = '<div style="color: #6b7280; text-align: center; padding: 20px; font-size: 14px;">No documents uploaded yet</div>';
            docCount.textContent = '0';
            return;
        }
        docCount.textContent = docs.length;
        documentList.innerHTML = docs.map(doc => `
            <div class="document-item">
                <div class="document-info">
                    <div class="document-name">${escapeHtml(doc.filename || 'Unknown')}</div>
                    <div class="document-meta">${doc.total_chunks || 0} chunks • ${doc.file_type || 'unknown'}</div>
                </div>
                <button class="view-chunks-btn" onclick="viewChunks('${escapeHtml(doc.filename || '')}')">View Chunks</button>
                <button class="delete-btn" onclick="deleteDocument('${escapeHtml(doc.filename || '')}')">×</button>
            </div>
        `).join('');
    }
    async function loadDocuments() {
        try {
            const response = await fetch('/api/documents');
            const docs = await response.json();
            renderDocuments(docs);
        } catch (error) {
            document.getElementById('documentList').innerHTML = '<div style="color: #6b7280; text-align: center; padding: 20px; font-size: 14px;">Error loading documents</div>';
            document.getElementById('docCount').textContent = '0';
        }
    }
    async function uploadFiles(files) {
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        document.getElementById('documentList').innerHTML = '<div style="color: #3b82f6; text-align: center; padding: 20px; font-size: 15px;"><span class="spinner" style="display:inline-block;width:18px;height:18px;border:3px solid #3b82f6;border-top:3px solid #e0e7ef;border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle;margin-right:8px;"></span>Processing legal document(s)...</div>';
        uploadArea.style.pointerEvents = 'none';
        uploadArea.style.opacity = '0.6';
        fileInput.disabled = true;
        for (const file of files) {
            await uploadFile(file);
        }
        uploadArea.style.pointerEvents = '';
        uploadArea.style.opacity = '';
        fileInput.disabled = false;
        loadDocuments();
    }
    async function uploadFile(file) {
        try {
            const formData = new FormData();
            formData.append('file', file);
            
            // Show initial upload notification
            showNotification(`📤 Uploading ${file.name}...`, 'info');
            
            const response = await fetch('/upload', {
                method: 'POST',
                body: formData,
                signal: AbortSignal.timeout(60000) // 60 second timeout for upload
            });
            
            if (response.ok) {
                const result = await response.json();
                
                if (result.processing_id) {
                    // Start monitoring processing progress
                    monitorProcessing(result.processing_id, file.name);
                } else {
                    // Immediate success (for small files)
                    showNotification(`✅ ${file.name} uploaded successfully`, 'success');
                }
            } else {
                const errorData = await response.json();
                throw new Error(errorData.error || `Failed to upload ${file.name}`);
            }
        } catch (error) {
            showNotification(`❌ Failed to upload ${file.name}: ${error.message}`, 'error');
        }
    }
    
    async function monitorProcessing(processingId, filename) {
        const maxAttempts = 900; // 15 minutes with 1-second intervals
        let attempts = 0;
        
        // Show progress bar
        const progressDiv = document.getElementById('uploadProgress');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        progressDiv.style.display = 'block';
        
        const checkStatus = async () => {
            try {
                const response = await fetch(`/api/processing/status/${processingId}`, {
                    signal: AbortSignal.timeout(10000) // 10 second timeout for status checks
                });
                
                if (response.ok) {
                    const status = await response.json();
                    
                    // Update progress bar
                    progressBar.style.width = `${status.progress}%`;
                    progressText.textContent = `${status.progress}%`;
                    
                    // Update notification with progress
                    if (status.status === 'processing') {
                        showNotification(`🔄 ${filename}: ${status.message} (${status.progress}%)`, 'info');
                        
                        if (attempts < maxAttempts) {
                            attempts++;
                            setTimeout(checkStatus, 1000);
                        } else {
                            showNotification(`⏰ ${filename}: Processing timeout`, 'error');
                            progressDiv.style.display = 'none';
                        }
                    } else if (status.status === 'completed') {
                        showNotification(`✅ ${filename}: ${status.message}`, 'success');
                        progressDiv.style.display = 'none';
                        loadDocuments(); // Refresh document list
                    } else if (status.status === 'error') {
                        showNotification(`❌ ${filename}: ${status.error}`, 'error');
                        progressDiv.style.display = 'none';
                    }
                } else {
                    showNotification(`❌ ${filename}: Failed to check processing status`, 'error');
                    progressDiv.style.display = 'none';
                }
            } catch (error) {
                showNotification(`❌ ${filename}: Error monitoring processing: ${error.message}`, 'error');
                progressDiv.style.display = 'none';
            }
        };
        
        // Start monitoring
        checkStatus();
    }
    async function deleteDocument(filename) {
        if (!confirm(`Delete ${filename}?`)) return;
        try {
            const response = await fetch(`/api/documents/${filename}`, { method: 'DELETE' });
            if (response.ok) {
                showNotification(`🗑️ ${filename} deleted`, 'success');
                loadDocuments();
            } else {
                throw new Error('Delete failed');
            }
        } catch (error) {
            showNotification(`❌ Failed to delete ${filename}`, 'error');
        }
    }
    // Chunk modal logic
    const chunkModalBg = document.getElementById('chunkModalBg');
    document.getElementById('closeChunkModal').onclick = () => { chunkModalBg.style.display = 'none'; };
    async function viewChunks(filename) {
        chunkModalBg.style.display = 'flex';
        document.getElementById('chunkModalTitle').textContent = `Chunks for: ${filename}`;
        document.getElementById('chunkModalBody').innerHTML = '<div style="color:#888;">Loading...</div>';
        try {
            const response = await fetch(`/api/documents/${filename}/chunks`);
            const data = await response.json();
            if (data.error) {
                document.getElementById('chunkModalBody').innerHTML = `<div style='color:#e53e3e;'>${escapeHtml(data.error)}</div>`;
                return;
            }
            if (!data.chunks || data.chunks.length === 0) {
                document.getElementById('chunkModalBody').innerHTML = '<div style="color:#888;">No chunks found for this document.</div>';
                return;
            }
            document.getElementById('chunkModalBody').innerHTML = data.chunks.map(chunk => `
                <div style="margin-bottom:18px;padding-bottom:12px;border-bottom:1px solid #eee;">
                    <div style="font-size:12px;color:#666;margin-bottom:4px;">
                        <b>Chunk #${chunk.index+1}</b> | <b>Section:</b> ${escapeHtml(chunk.section_number)} - ${escapeHtml(chunk.section_title)} | <b>Type:</b> ${escapeHtml(chunk.chunk_type)} | <b>Pages:</b> ${escapeHtml(chunk.pages)}
                    </div>
                    <div style="white-space:pre-wrap;">${escapeHtml(chunk.text)}</div>
                </div>
            `).join('');
        } catch (error) {
            document.getElementById('chunkModalBody').innerHTML = `<div style='color:#e53e3e;'>Failed to load chunks: ${escapeHtml(error.message)}</div>`;
        }
    }
    // File upload drag/drop
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', e => {
        e.preventDefault();
        uploadArea.style.borderColor = '#2563eb';
        uploadArea.style.background = '#e0e7ef';
    });
    uploadArea.addEventListener('dragleave', e => {
        e.preventDefault();
        uploadArea.style.borderColor = '#3b82f6';
        uploadArea.style.background = '#f3f4f6';
    });
    uploadArea.addEventListener('drop', e => {
        e.preventDefault();
        uploadArea.style.borderColor = '#3b82f6';
        uploadArea.style.background = '#f3f4f6';
        const files = Array.from(e.dataTransfer.files);
        uploadFiles(files);
    });
    fileInput.addEventListener('change', e => {
        const files = Array.from(e.target.files);
        uploadFiles(files);
    });
    // Instructions button events
    document.getElementById('saveInstructionsBtn').addEventListener('click', saveInstructions);
    document.getElementById('resetInstructionsBtn').addEventListener('click', resetInstructions);
    
    // Extraction configuration events
    document.getElementById('extractionMethodSelect').addEventListener('change', function() {
        updateExtractionUI();
        saveExtractionConfig();
    });
    document.getElementById('temperatureInput').addEventListener('input', function() {
        document.getElementById('temperatureValue').textContent = Number(this.value).toFixed(2);
    });
    document.getElementById('temperatureInput').addEventListener('change', saveExtractionConfig);
    
    document.getElementById('gpt4ModelSelect').addEventListener('change', saveExtractionConfig);
    
    // Chunking method dropdown
    document.getElementById('chunkingMethodSelect').addEventListener('change', function() {
        updateExtractionUI();  // Update UI to show/hide LangExtract notice
        saveExtractionConfig();
    });
    
    // GPT-4 feature checkboxes
    document.getElementById('enableTextEnhancement').addEventListener('change', saveExtractionConfig);
    document.getElementById('enableStructuredData').addEventListener('change', saveExtractionConfig);
    document.getElementById('enableContractAnalysis').addEventListener('change', saveExtractionConfig);
    document.getElementById('enableDocumentSummary').addEventListener('change', saveExtractionConfig);
    
    // OCR configuration
    document.getElementById('enableOcr').addEventListener('change', saveExtractionConfig);
    
    // Test extraction button
    document.getElementById('testExtractionBtn').addEventListener('click', async function() {
        const button = this;
        const originalText = button.textContent;
        button.textContent = 'Testing...';
        button.disabled = true;
        
        try {
            const response = await fetch('/api/extract/test', {
                method: 'POST'
            });
            
            if (response.ok) {
                const result = await response.json();
                showNotification('✅ Extraction test completed successfully', 'success');
                
                // Show test results in a simple alert (could be enhanced with a modal)
                const testResults = Object.keys(result.results).map(key => 
                    `${key}: ${result.results[key].success ? '✅' : '❌'}`
                ).join('\n');
                
                alert(`Extraction Test Results:\n\n${testResults}`);
            } else {
                const error = await response.json();
                showNotification(`❌ Extraction test failed: ${error.error}`, 'error');
            }
        } catch (error) {
            showNotification('❌ Extraction test failed: Network error', 'error');
        } finally {
            button.textContent = originalText;
            button.disabled = false;
        }
    });
    
    // Initial load
    loadModels();
    loadInstructions();
    loadDocuments();
    loadExtractionConfig(); // Load extraction config on page load
    updateExtractionUI(); // Update UI based on initial extraction method
    loadExtractionStatus(); // Load extraction status on page load
    // Notification
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
    }
    </script>
</body>
</html> 