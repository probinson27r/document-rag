name: Deploy to EC2

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-southeast-2
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest
    
    - name: Run tests
      run: |
        python -m pytest tests/ -v

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Create deployment package
      run: |
        # Create deployment directory
        mkdir -p deployment
        cp -r app.py document_rag.py hybrid_search.py legal_document_rag.py deployment/
        cp -r templates static deployment/
        cp requirements.txt deployment/
        cp -r cognito_auth.py aws_secrets.py export_utils.py deployment/
        cp -r gpt4_chunking.py gpt4_extraction.py semantic_chunking.py langextract_chunking.py deployment/
        cp -r cli.py flask_app.py deployment/
        
        # Create necessary directories
        mkdir -p deployment/uploads
        mkdir -p deployment/chroma_db
        mkdir -p deployment/flask_session
        
        # Create deployment script
        cat > deployment/deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üöÄ Starting deployment..."
        
        # Stop existing application
        if pgrep -f "python.*app.py" > /dev/null; then
            echo "üõë Stopping existing application..."
            pkill -f "python.*app.py" || true
            sleep 5
        fi
        
        # Install/update dependencies
        echo "üì¶ Installing dependencies..."
        pip install -r requirements.txt
        
        # Set up environment
        echo "üîß Setting up environment..."
        export FLASK_ENV=production
        export FLASK_APP=app.py
        
        # Start application
        echo "üöÄ Starting application..."
        nohup python app.py > app.log 2>&1 &
        echo $! > app.pid
        
        echo "‚úÖ Deployment completed!"
        echo "üìã Application PID: $(cat app.pid)"
        echo "üìÑ Logs: tail -f app.log"
        EOF
        
        chmod +x deployment/deploy.sh
        
        # Create tar.gz
        tar -czf deployment.tar.gz deployment/
    
    - name: Validate SSH host and key
      run: |
        set -e
        # Read and sanitize host from secret
        HOST_RAW="${{ secrets.EC2_INSTANCE_IP }}"
        HOST_TRIMMED=$(echo "$HOST_RAW" | tr -d ' \t\r\n')
        if [ -z "$HOST_TRIMMED" ]; then
          echo "::error::EC2_INSTANCE_IP GitHub secret is missing or empty"
          exit 1
        fi
        # If user included username in the secret, respect it; otherwise default to ubuntu@
        if echo "$HOST_TRIMMED" | grep -q "@"; then
          USER_HOST="$HOST_TRIMMED"
        else
          USER_HOST="ubuntu@$HOST_TRIMMED"
        fi
        echo "Using SSH target: $USER_HOST"

        # Prepare SSH key (handle both real newlines and escaped \n)
        echo "${{ secrets.SSH_PRIVATE_KEY }}" | sed 's/\\n/\n/g' > ssh_key
        chmod 600 ssh_key

        # Basic DNS/port checks (non-fatal DNS info)
        which dig >/dev/null 2>&1 && dig +short "${HOST_TRIMMED}" || true
        which nslookup >/dev/null 2>&1 && nslookup "${HOST_TRIMMED}" || true

        # Check SSH connectivity quickly
        ssh -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=15 "$USER_HOST" "echo 'SSH connectivity OK'" || {
          echo "::error::Unable to reach $USER_HOST via SSH. Check EC2 public IP/DNS, security groups (port 22), and that the key matches the instance."
          exit 1
        }

        # Export for subsequent steps
        echo "USER_HOST=$USER_HOST" >> $GITHUB_ENV

    - name: Deploy to EC2
      run: |
        set -e
        # ssh_key prepared in previous step; USER_HOST exported
        
        # Copy deployment package
        scp -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 deployment.tar.gz "$USER_HOST":/home/ubuntu/
        
        # Execute deployment
        ssh -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 "$USER_HOST" << 'EOF'
          set -e
          
          echo "üì¶ Extracting deployment package..."
          tar -xzf deployment.tar.gz
          
          echo "üîÑ Updating application..."
          sudo rm -rf /opt/legal-rag-app
          sudo mv deployment /opt/legal-rag-app
          sudo chown -R ubuntu:ubuntu /opt/legal-rag-app
          
          cd /opt/legal-rag-app
          ./deploy.sh
          
          echo "‚úÖ Deployment completed successfully!"
        EOF
        
        # Clean up
        rm -f ssh_key
    
    - name: Health check
      run: |
        set -e
        # ssh_key prepared earlier; USER_HOST exported
        
        # Wait for application to start
        sleep 30
        
        # Check if application is running
        ssh -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 "$USER_HOST" << 'EOF'
          if pgrep -f "python.*app.py" > /dev/null; then
            echo "‚úÖ Application is running"
            curl -f http://localhost:5001/health || echo "‚ùå Health check failed"
          else
            echo "‚ùå Application is not running"
            exit 1
          fi
        EOF
        
        rm -f ssh_key
