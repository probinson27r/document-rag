name: Deploy to EC2

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-southeast-2
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

jobs:
  
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Create deployment package
      run: |
        # Create deployment directory
        mkdir -p deployment
        cp -r app.py document_rag.py hybrid_search.py legal_document_rag.py deployment/
        cp -r templates static deployment/
        cp requirements.txt deployment/
        cp -r cognito_auth.py aws_secrets.py export_utils.py deployment/
        cp -r gpt4_chunking.py gpt4_extraction.py semantic_chunking.py langextract_chunking.py deployment/
        cp -r cli.py flask_app.py deployment/
        
        # Copy systemd service file if it exists
        if [ -f "legal-rag.service" ]; then
          cp legal-rag.service deployment/
        fi
        
        # Create necessary directories
        mkdir -p deployment/uploads
        mkdir -p deployment/chroma_db
        mkdir -p deployment/flask_session
        
        # Create deployment script
        cat > deployment/deploy.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e
        
        echo "üöÄ Starting deployment..."
        
        # Stop systemd service if running
        echo "üõë Stopping legal-rag service..."
        sudo systemctl stop legal-rag 2>/dev/null || true
        
        # Smart virtual environment management
        echo "üîß Managing virtual environment..."
        
        # Check if we need to rebuild venv (compare requirements.txt hash)
        REQUIREMENTS_HASH=$(sha256sum requirements.txt | cut -d' ' -f1)
        VENV_HASH_FILE="venv/.requirements_hash"
        REBUILD_VENV=false
        
        if [ ! -d "venv" ]; then
            echo "üìù No existing virtual environment found - creating new one"
            REBUILD_VENV=true
        elif [ ! -f "$VENV_HASH_FILE" ]; then
            echo "üìù No requirements hash found - rebuilding venv"
            REBUILD_VENV=true
        else
            STORED_HASH=$(cat "$VENV_HASH_FILE" 2>/dev/null || echo "")
            if [ "$REQUIREMENTS_HASH" != "$STORED_HASH" ]; then
                echo "üìù Requirements.txt changed - rebuilding venv"
                echo "   Old hash: $STORED_HASH"
                echo "   New hash: $REQUIREMENTS_HASH"
                REBUILD_VENV=true
            else
                echo "‚úÖ Requirements unchanged - reusing existing venv"
                echo "   Hash: $REQUIREMENTS_HASH"
            fi
        fi
        
        if [ "$REBUILD_VENV" = true ]; then
            # Backup existing venv for rollback if needed
            if [ -d "venv" ]; then
                echo "üíæ Backing up existing venv..."
                sudo mv venv venv.backup.$(date +%s) || true
            fi
            
            # Create fresh virtual environment
            echo "üÜï Creating fresh virtual environment..."
            python3 -m venv venv
            source venv/bin/activate
            
            # Upgrade pip
            pip install --upgrade pip
            
            # Install dependencies (with cache for faster installs)
            echo "üì¶ Installing dependencies..."
            pip install -r requirements.txt
            
            # Store requirements hash for future comparisons
            echo "$REQUIREMENTS_HASH" > "$VENV_HASH_FILE"
            echo "‚úÖ Virtual environment created and hash stored"
            
            # Clean up old backups (keep only last 2)
            echo "üßπ Cleaning up old venv backups..."
            ls -1t venv.backup.* 2>/dev/null | tail -n +3 | xargs rm -rf || true
        else
            # Activate existing venv
            source venv/bin/activate
            
            # Quick pip upgrade check (much faster than full rebuild)
            echo "‚ö° Quick pip upgrade check..."
            pip install --upgrade pip --quiet
        fi
        
        # Verify critical dependencies
        echo "üîç Verifying dependencies..."
        python -c "import flask; print(f'Flask: {flask.__version__}')"
        python -c "import numpy; print(f'NumPy: {numpy.__version__}')"
        
        # Set proper permissions
        sudo chown -R ubuntu:ubuntu /opt/legal-rag-app
        
        # Create systemd service file
        echo "‚öôÔ∏è Setting up systemd service..."
        echo "[Unit]" > /tmp/legal-rag.service
        echo "Description=Legal Document RAG System" >> /tmp/legal-rag.service
        echo "After=network.target" >> /tmp/legal-rag.service
        echo "" >> /tmp/legal-rag.service
        echo "[Service]" >> /tmp/legal-rag.service
        echo "Type=simple" >> /tmp/legal-rag.service
        echo "User=ubuntu" >> /tmp/legal-rag.service
        echo "WorkingDirectory=/opt/legal-rag-app" >> /tmp/legal-rag.service
        echo "Environment=PATH=/opt/legal-rag-app/venv/bin" >> /tmp/legal-rag.service
        echo "ExecStart=/opt/legal-rag-app/venv/bin/python app.py --host 0.0.0.0 --port 5001" >> /tmp/legal-rag.service
        echo "Restart=always" >> /tmp/legal-rag.service
        echo "RestartSec=3" >> /tmp/legal-rag.service
        echo "" >> /tmp/legal-rag.service
        echo "[Install]" >> /tmp/legal-rag.service
        echo "WantedBy=multi-user.target" >> /tmp/legal-rag.service
        
        # Install the service file
        sudo mv /tmp/legal-rag.service /etc/systemd/system/legal-rag.service
        
        # Reload systemd and enable service
        sudo systemctl daemon-reload
        sudo systemctl enable legal-rag
        
        # Start the service
        echo "üöÄ Starting legal-rag service..."
        sudo systemctl start legal-rag
        
        # Wait for startup (dependencies installation can take time)
        sleep 15
        
        # Check service status
        if sudo systemctl is-active legal-rag >/dev/null; then
            echo "‚úÖ Service started successfully"
            sudo systemctl status legal-rag --no-pager -l
        else
            echo "‚ùå Service failed to start"
            sudo systemctl status legal-rag --no-pager -l
            sudo journalctl -u legal-rag --no-pager -n 20
            exit 1
        fi
        
        echo "‚úÖ Deployment completed!"
        DEPLOYEOF
        
        chmod +x deployment/deploy.sh
        
        # Create tar.gz
        tar -czf deployment.tar.gz deployment/
    
    - name: Validate SSH host and key
      run: |
        set -e
        # Read and sanitize host from secret
        HOST_RAW="${{ secrets.EC2_INSTANCE_IP }}"
        HOST_TRIMMED=$(echo "$HOST_RAW" | tr -d ' \t\r\n')
        if [ -z "$HOST_TRIMMED" ]; then
          echo "::error::EC2_INSTANCE_IP GitHub secret is missing or empty"
          exit 1
        fi
        # If user included username in the secret, respect it; otherwise default to ubuntu@
        if echo "$HOST_TRIMMED" | grep -q "@"; then
          USER_HOST="$HOST_TRIMMED"
        else
          USER_HOST="ubuntu@$HOST_TRIMMED"
        fi
        echo "Using SSH target: $USER_HOST"

        # Prepare SSH key (handle both real newlines and escaped \n)
        echo "${{ secrets.SSH_PRIVATE_KEY }}" | sed 's/\\n/\n/g' > ssh_key
        chmod 600 ssh_key

        # Basic DNS/port checks (non-fatal DNS info)
        which dig >/dev/null 2>&1 && dig +short "${HOST_TRIMMED}" || true
        which nslookup >/dev/null 2>&1 && nslookup "${HOST_TRIMMED}" || true

        # Check SSH connectivity quickly
        ssh -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=15 "$USER_HOST" "echo 'SSH connectivity OK'" || {
          echo "::error::Unable to reach $USER_HOST via SSH. Check EC2 public IP/DNS, security groups (port 22), and that the key matches the instance."
          exit 1
        }

        # Export for subsequent steps
        echo "USER_HOST=$USER_HOST" >> $GITHUB_ENV

    - name: Deploy to EC2
      run: |
        set -e
        # Recreate SSH key for this step (USER_HOST available from environment)
        echo "${{ secrets.SSH_PRIVATE_KEY }}" | sed 's/\\n/\n/g' > ssh_key
        chmod 600 ssh_key
        
        # Copy deployment package
        scp -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 deployment.tar.gz "$USER_HOST":/home/ubuntu/
        
        # Execute deployment
        ssh -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 "$USER_HOST" << 'SSHEOF'
          set -e
          
          echo "üì¶ Extracting deployment package..."
          tar -xzf deployment.tar.gz
          
          echo "üîÑ Updating application..."
          
          # Backup persistent data before deployment
          if [ -d "/opt/legal-rag-app" ]; then
            echo "üíæ Backing up persistent data and virtual environment..."
            sudo mkdir -p /tmp/backup
            if [ -d "/opt/legal-rag-app/chroma_db" ]; then
              sudo cp -r /opt/legal-rag-app/chroma_db /tmp/backup/ || true
            fi
            if [ -d "/opt/legal-rag-app/uploads" ]; then
              sudo cp -r /opt/legal-rag-app/uploads /tmp/backup/ || true
            fi
            if [ -d "/opt/legal-rag-app/flask_session" ]; then
              sudo cp -r /opt/legal-rag-app/flask_session /tmp/backup/ || true
            fi
            # Backup virtual environment for reuse
            if [ -d "/opt/legal-rag-app/venv" ]; then
              echo "üì¶ Backing up virtual environment..."
              sudo cp -r /opt/legal-rag-app/venv /tmp/backup/ || true
            fi
          fi
          
          # Remove old application directory
          sudo rm -rf /opt/legal-rag-app
          
          # Move new application
          sudo mv deployment /opt/legal-rag-app
          sudo chown -R ubuntu:ubuntu /opt/legal-rag-app
          
          # Restore persistent data
          if [ -d "/tmp/backup" ]; then
            echo "üîÑ Restoring persistent data..."
            if [ -d "/tmp/backup/chroma_db" ]; then
              sudo rm -rf /opt/legal-rag-app/chroma_db
              sudo mv /tmp/backup/chroma_db /opt/legal-rag-app/
            fi
            if [ -d "/tmp/backup/uploads" ]; then
              sudo rm -rf /opt/legal-rag-app/uploads
              sudo mv /tmp/backup/uploads /opt/legal-rag-app/
            fi
            if [ -d "/tmp/backup/flask_session" ]; then
              sudo rm -rf /opt/legal-rag-app/flask_session
              sudo mv /tmp/backup/flask_session /opt/legal-rag-app/
            fi
            # Restore virtual environment for smart reuse
            if [ -d "/tmp/backup/venv" ]; then
              echo "üì¶ Restoring virtual environment..."
              sudo mv /tmp/backup/venv /opt/legal-rag-app/
            fi
            # Clean up backup
            sudo rm -rf /tmp/backup
            echo "‚úÖ Persistent data restored"
          fi
          
          # Ensure proper ownership after restore
          sudo chown -R ubuntu:ubuntu /opt/legal-rag-app
          
          cd /opt/legal-rag-app
          
          # Verify persistent data directories exist
          echo "üîç Verifying persistent data directories..."
          ls -la chroma_db/ 2>/dev/null && echo "‚úÖ ChromaDB directory exists" || echo "‚ö†Ô∏è  ChromaDB directory is empty (first deployment)"
          ls -la uploads/ 2>/dev/null && echo "‚úÖ Uploads directory exists" || echo "‚ÑπÔ∏è  Uploads directory is empty"
          
          ./deploy.sh
          
          echo "‚úÖ Deployment completed successfully!"
        SSHEOF
        
        # Note: SSH key will be recreated in health check step
    
    - name: Health check
      run: |
        set -e
        # Recreate SSH key for this step (USER_HOST available from environment)
        echo "${{ secrets.SSH_PRIVATE_KEY }}" | sed 's/\\n/\n/g' > ssh_key
        chmod 600 ssh_key
        
        echo "üîç Health checking $USER_HOST..."
        
        # Wait for application to start (optimized timing with smart venv management)
        echo "‚è≥ Waiting 45 seconds for application to initialize..."
        sleep 45
        
        # Robust health check with retries
        ssh -i ssh_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 "$USER_HOST" << 'HEALTHEOF'
          echo "üîç Starting health check process..."
          
          # Function to check service with retries
          check_service_health() {
            local max_attempts=6
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "üîÑ Health check attempt $attempt/$max_attempts..."
              
              # Check if service is active
              if ! sudo systemctl is-active legal-rag >/dev/null; then
                echo "‚ùå Service is not active on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• Service failed to start after $max_attempts attempts"
                  sudo systemctl status legal-rag --no-pager -l
                  sudo journalctl -u legal-rag --no-pager -n 30
                  return 1
                fi
                sleep 10
                attempt=$((attempt + 1))
                continue
              fi
              
              echo "‚úÖ Service is active"
              
              # Check if port is listening
              if ! sudo netstat -tlnp | grep :5001 >/dev/null; then
                echo "‚ö†Ô∏è  Port 5001 not yet listening on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• Port 5001 never started listening"
                  sudo systemctl status legal-rag --no-pager -l
                  return 1
                fi
                sleep 10
                attempt=$((attempt + 1))
                continue
              fi
              
              echo "‚úÖ Port 5001 is listening"
              
              # Test health endpoint
              if curl -f http://localhost:5001/health >/dev/null 2>&1; then
                echo "‚úÖ Health check passed on attempt $attempt!"
                echo "üåê ALB should be able to reach the application"
                return 0
              else
                echo "‚ö†Ô∏è  Health endpoint not responding on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• Health endpoint failed after $max_attempts attempts"
                  # Show more debug info
                  echo "üîç Debug info:"
                  curl -v http://localhost:5001/health || true
                  sudo journalctl -u legal-rag --no-pager -n 20
                  return 1
                fi
                sleep 10
                attempt=$((attempt + 1))
              fi
            done
          }
          
          # Run the health check
          check_service_health
        HEALTHEOF
        
        rm -f ssh_key
